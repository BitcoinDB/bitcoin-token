!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("bitcoinsource"),require("axios")):"function"==typeof define&&define.amd?define(["exports","bitcoinsource","axios"],e):e((t["bitcoin-token-umd"]=t["bitcoin-token-umd"]||{},t["bitcoin-token-umd"].js={}),t.BitcoreLib,t.axios)}(this,function(t,e,a){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,a=a&&a.hasOwnProperty("default")?a.default:a;var s={BITCOIN_NETWORK:"testnet",BLOCK_EXPLORER_URL:"http://test-insight-4.yours.org/insight-api",CHAIN:"bitcoin-cash",MIN_SATOSHI_AMOUNT:5e3,UN_P2SH_URL:"http://localhost:3000",DEFAULT_FEE:1e4};function r(t){return Buffer.from(t)}function n(t){return t.toString()}e.versionGuard=(()=>!0),e.Networks.defaultNetwork=e.Networks[s.BITCOIN_NETWORK];class i{constructor(t,e,a){this.publicKeys=e||[],this.data=t||[],this.amount=a||s.MIN_SATOSHI_AMOUNT}getData(t){return this.data[t]}getSerializeData(){return Object.entries(this.data).reduce((t,e)=>t.concat(e),[]).map(r)}setSerializedData(t){const e=t.map(n),a={};for(let t=0;t<e.length;t+=2)a[e[t]]=e[t+1];this.data=a}toJSON(){return{data:this.data,publicKeys:this.publicKeys.map(t=>t.toString()),amount:this.amount}}}const{Address:u,PublicKey:o,Signature:c,Script:d,Opcode:h}=e;class p extends d{static buildDataOut(t){const{publicKeys:e}=t,a=t.getSerializeData(),s=new p;return s.add("OP_1"),e.forEach(t=>s.add(t.toBuffer())),s.add(`OP_${e.length}`),s.add("OP_CHECKMULTISIG"),a.forEach(t=>s.add(t).add("OP_DROP")),s}static buildDataIn(t,e,a,s){const r=new p;return a.forEach(t=>{r.add(t)}),r.add(s),r}isData(){return!(!(this.chunks.length>=5&&this.chunks[0].opcodenum===h.OP_1&&this.chunks[1].buf)||20!==this.chunks[1].buf.length&&33!==this.chunks[1].buf.length||this.chunks[2].opcodenum!==h.OP_1||this.chunks[3].opcodenum!==h.OP_CHECKMULTISIG||!this.chunks[4].buf||this.chunks[5].opcodenum!==h.OP_DROP)}toData(){if(!this.isData())return"no_data";const t=new i({},[new o(this.chunks[1].buf)],s.MIN_SATOSHI_AMOUNT),e=this.chunks.slice(4,this.chunks.length).filter((t,e)=>e%2==0).map(t=>t.buf);return t.setSerializedData(e),t}}class l extends Error{constructor(t,e,...a){super(...a),this.name="TokenError",this.message=t+(e?`: ${e}`:""),Error.captureStackTrace&&Error.captureStackTrace(this,l)}}const y=async t=>{try{return(await t).data}catch(t){if(t.response){const{status:e,statusText:a,data:s}=t.response,r=s.error||(-1!==s.indexOf("Code:")?s:a);throw new l("Communication error",`${a}. Failed with status ${e}. Txo: ${r}.`)}throw new l("Communication error","Service unavailable.")}},w=async(t,e=s.BLOCK_EXPLORER_URL)=>y(a.get(`${e}${t}`)),g=async(t,e,r=s.BLOCK_EXPLORER_URL)=>y(a.post(`${r}${t}`,e)),b=async t=>{const{balanceSat:e,unconfirmedBalanceSat:a}=await(async t=>w(`/addr/${t.toString()}`))(t);return e+a},m=async t=>g("/tx/send",{rawtx:t.toString()}),f=async t=>{return(await w(`/rawtx/${t}`)).rawtx},O=async t=>{const e=t.toString();return(t=>t.filter((t,e,a)=>a.findIndex(e=>e.txid===t.txid&&e.vout===t.vout)===e))(await w(`/addr/${e}/utxo`)).map(t=>(t.spent=!1,t))},P=async t=>{const e=await(async t=>w(`/tx/${t}`))(t.txId),a=e.vout[t.outputNumber],s=a.scriptPubKey.addresses[0],r=t.txId,n=t.outputNumber,i=parseFloat(a.value),u=1e8*i,o=e.blockheight,{confirmations:c}=e,d=!!a.spentTxId&&a.spentTxId;return{address:s,txid:r,vout:n,scriptPubKey:a.scriptPubKey.hex,amount:i,satoshis:u,height:o,confirmations:c,spent:d}},_=async t=>g("/",t,s.UN_P2SH_URL),S=async t=>w(`/un-p2sh/${t}`,s.UN_P2SH_URL),K=async t=>w(`/txos/${t}`,s.UN_P2SH_URL),I=async(t,e)=>g("/txos/set-spent/",{txId:t,vOut:e},s.UN_P2SH_URL),{Transaction:D,PublicKey:v,Address:x,BN:A,Script:E,encoding:T}=e,{Output:k,Input:H}=D,{MultiSigScriptHash:U}=H,{BufferReader:N}=T;class R extends D{constructor(t){super(t),this._dataOutputs=[],Object.defineProperty(this,"to",{writable:!0,value:this._to})}get dataInputs(){return this.inputs.map((t,e)=>t.redeemScript?t.redeemScript.toData(e):"no_data")}set dataInputs(t){throw Error("dataTransaction.dataInputs cannot be set directly, use dataTransaction.from or dataTransaction.fromData")}fromData(t,e){const a=p.buildDataOut(e),s=new U({output:new k({script:new p(t.scriptPubKey),satoshis:t.satoshis}),prevTxId:t.txid,outputIndex:t.vout,script:new p},e.publicKeys,1,null,a);return this.addInput(s),this}getRedeemScriptFromInput(t){if(this.inputs.length<=t)throw new Error("Input number must be smaller than number of inputs");return this.inputs[t].redeemScript||"no_data"}isInputData(t,e){if(this.inputs.length<=e)throw new Error("Input number must be smaller than number of inputs");if("no_data"===t)return!this.isDataInput(e);const a=p.buildDataOut(t),s=this.getRedeemScriptFromInput(e);return a.toString()===s.toString()}isInData(t){if(this.inputs.length!==t.length)return!1;return[...this.inputs.keys()].every(e=>this.isInputData(t[e],e))}isDataInput(t){if(this.inputs.length<=t)throw new Error("Input number must be smaller than number of inputs");return"no_data"!==this.getRedeemScriptFromInput(t)}get dataOutputs(){return this._dataOutputs.map(t=>"no_data"===t?t:new i(t.data,t.publicKeys))}set dataOutputs(t){throw Error("dataTransaction.dataInputs cannot be set directly, use dataTransaction.toData")}_to(t,e){return this._dataOutputs.push("no_data"),super.to(t,e)}toData(t){const e=p.buildDataOut(t),a=p.buildScriptHashOut(e),s=new k({script:a,satoshis:t.amount});return this.addOutput(s),this._dataOutputs.push(t),this}isOutputData(t,e){if(this.outputs.length<=e)throw new Error("isOutputData: Output number must be smaller than number of outputs");if("no_data"===t){const t=this.outputs[e].script.toString();return"Pay to script hash"!==p.fromString(t).classifyOutput()}const a=p.buildDataOut(t);return this.isOutputRedeemScript(a,e)}isOutData(t){if(this.outputs.length!==t.length)return!1;return[...this.outputs.keys()].every(e=>this.isOutputData(t[e],e))}isOutputRedeemScript(t,e){if(this.outputs.length<=e)throw new Error("isOutputRedeemScript: Output number must be smaller than number of outputs");const a=this.outputs[e].script;return p.buildScriptHashOut(t).toString()===a.toString()}async fetchDataOutputs(){const t=this.getId(),e=await S(t);if(!e)throw new Error(`Cannot find output string for txId ${t} in database`);return this._dataOutputs=e.map(t=>"no_data"===t?"no_data":new i(t.data,t.publicKeys.map(v.fromString))),this._dataOutputs}getOutputData(t,e){if(!this.dataOutputs)throw new Error("Need to fetch output data before retrieving it");const a=this.dataOutputs[t];if(!a||"no_data"===a)throw new Error("Not a data output");return a.data[e]}getId(){return new N(this._getHash()).readReverse().toString("hex")}async fromTxId(t){const e=await f(t);return await this.fromString(e),this}isIssuance(t){const e=[...this.inputs.keys()].every(t=>!this.isDataInput(t)),a=this.isOutData(t)||this.isOutData(t.concat(["no_data"]));return e&&a}isTransfer(t,e){const a=this.isInData(t)||this.isInData(t.concat(["no_data"])),s=this.isOutData(e)||this.isOutData(e.concat(["no_data"]));return a&&s}async getAncestors(){return await this.fetchDataOutputs(),{node:this,ancestors:await Promise.all(this.inputs.map(async(t,e)=>{if(!this.isDataInput(e))return"no_data";const a=t.prevTxId.toString("hex");return(await(new R).fromTxId(a)).getAncestors()}))}}static getGodFather(t){const{node:e,ancestors:a}=t,s=a.filter(t=>"no_data"!==t);return e.isIssuance(e.dataOutputs)?e:!!s.length&&R.getGodFather(s[0])}static isValid(t){const{node:e,ancestors:a}=t;return e.isIssuance(e.dataOutputs)?a.every(t=>"no_data"===t):!!e.isTransfer(e.dataInputs,e.dataOutputs)&&a.every(t=>R.isValid(t))}}const{HDPrivateKey:L,PrivateKey:F,PublicKey:B,Address:$}=e;class j{constructor(t){this.hdPrivateKey=t||new L}derive(t=0,e=!0){return new j(this.hdPrivateKey.derive(t,e))}static getHdPrivateKey(){return new L}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address=this.address||this.getPublicKey().toAddress(),this.address}async getBalance(){const t=this.getAddress();return b(t.toString())}async getUtxosFromAddress(t,e){const a=await O(t.toString());let s=0;const r=[];let n=0;for(;s<e&&n<a.length;)r.push(a[n]),s+=a[n].satoshis,n+=1;if(s<e)throw new Error(`Insufficient balance in address ${t.toString()}`);return r}async getUtxos(t){const e=this.getAddress();return this.getUtxosFromAddress(e,t)}async getTokenUtxos(){const t=this.getPublicKey(),e=await K(t.toString());return Promise.all(e.map(async t=>{const e=await(new R).fromTxId(t.txId),a=(await e.fetchDataOutputs())[t.vOut];if(a){const s=p.buildDataOut(a),r=p.buildScriptHashOut(s),n=e.outputs[t.vOut].satoshis;return{txid:t.txId,vout:t.vOut,scriptPubKey:r,amount:Math.round(n/1e8),satoshis:n,amountSat:n,dataOutput:a}}return null}))}async sendTransaction(t,e=!1){const a=await m(t);if(e){const e={txId:a.txid,outputData:JSON.stringify(t.dataOutputs)};await _(e)}return a}async send(t,e,a){const r=a||this.getAddress(),n=s.DEFAULT_FEE,i=this.getPrivateKey(),u=await this.getUtxos(t+n),o=(new R).from(u).to(e,t).change(r).sign(i);return this.sendTransaction(o)}async sendAll(t){const e=await this.getBalance();if(e>s.DEFAULT_FEE){const a=s.DEFAULT_FEE;return this.send(e-a,t,t)}return{}}}const{HDPrivateKey:C,PublicKey:M}=e;class G{constructor(t){this.wallet=t||new j}static fromHdPrivateKey(t){return new this(new j(t))}async put(t){return this.update([],t)}async get(t){return Promise.all(t.map(async t=>{const{txId:e,outputNumber:a}=t,s=await(new R).fromTxId(e);return await s.fetchDataOutputs(),s.dataOutputs[a]}))}async update(t,e){const a=new R;await Promise.all(t.map(async t=>{const e=await P(t),s=(await S(e.txid))[e.vout],{publicKeys:r,data:n}=s,u=r.map(t=>new M(t));await I(e.txid,e.vout),a.fromData(e,new i(n,u))}));const s=await this.wallet.getUtxos(15e3);a.from(s);for(const t of e)a.toData(t);a.change(this.wallet.getAddress()),a.sign(this.wallet.getPrivateKey());const r=await this.wallet.sendTransaction(a,!0);return[...Array(e.length).keys()].map(t=>({txId:r.txid,outputNumber:t}))}}class z{constructor(t){this.db=t||new G}static fromHdPrivateKey(t){return new this(G.fromHdPrivateKey(t))}async init(t){const e=Object.getPrototypeOf(async()=>{}).constructor;Object.entries(t).forEach(([t,a])=>{this[t]=new e(`"use strict"; return ${a}`).bind(this)()})}async create(t){const e=new i(t,[this.db.wallet.getPublicKey()]);return(await this.db.put([e]))[0]}async send(t,e){const a=await this.db.wallet.getTokenUtxos();let s=0;const r=a.filter(async e=>{const a=s<t,{txid:r,vout:n,dataOutput:i}=e,{balance:u}=i.data;return s+=u?parseInt(u,10):0,await I(r,n),a}).map(t=>({txId:t.txid,outputNumber:t.vout}));if(s<t)throw new Error("Insufficient token funds");const n=new i({balance:t.toString(10)},[e]),u=s-t,o=this.db.wallet.getPublicKey(),c=new i({balance:u.toString(10)},[o]);return this.db.update(r,[n,c])}async getBalance(){const t=await this.db.wallet.getTokenUtxos();return(await Promise.all(t.map(async t=>{const e=await S(t.txid),{publicKeys:a,data:s}=e[t.vout],r=new i(s,a).getData("balance");return r?parseInt(r,10):0}))).reduce((t,e)=>t+e,0)}async verify(t){const e=await(new R).fromTxId(t),a=await e.getAncestors();return R.isValid(a)}}const{Address:V,HDPrivateKey:W}=e;class X{constructor(){this.wallet=new j}static fromHdPrivateKey(t){const e=new X,a=W.fromString(t);return e.wallet=new j(a),e}derive(t=0,e=!0){const a=new X,s=this.wallet.derive(t,e);return a.wallet=s,a}getPrivateKey(){return this.wallet.getPrivateKey().toString()}getPublicKey(){return this.wallet.getPublicKey().toString()}getAddress(t){const e=t||"bitpay";if(!["legacy","bitpay","cashaddr"].includes(e))throw new Error("'format' parameter in wallet.getAddress must be 'legacy', 'bitpay', or 'cashaddr'");return this.wallet.getAddress().toString(e)}async getBalance(){return this.wallet.getBalance()}async send(t,e,a){const s=new V(e,"testnet"),r=a?new V(a,"testnet"):this.wallet.getAddress();return this.wallet.send(t,s,r)}static getHdPrivateKey(){return j.getHdPrivateKey().toString()}}const{HDPrivateKey:q,PublicKey:J}=e;class Q{constructor(t){this.db=new G(t?t.wallet:null)}static fromHdPrivateKey(t){const e=new Q,a=q.fromString(t);return e.db=G.fromHdPrivateKey(a),e}_toOutputData(t){const{data:e,amount:a}=t,s=t.owners?t.owners.map(t=>new J(t)):[this.db.wallet.getPublicKey()];return new i(e,s,a)}_fromOutputData(t){return{data:t.data,owners:t.publicKeys.map(t=>t.toString()),amount:t.amount||s.MIN_SATOSHI_AMOUNT}}async putObject(t,e,a=s.DEFAULT_FEE){const r={data:t,owners:e,amount:a};return(await this.db.put([this._toOutputData(r)]))[0]}async putArray(t){return this.db.put(t.map(this._toOutputData.bind(this)))}async put(t,e,a=s.DEFAULT_FEE){return Array.isArray(t)?this.putArray(t):this.putObject(t,e||[this.getPublicKey()],a)}async getObject(t){const[e]=await this.db.get([t]);return"no_data"===e?{data:{},owners:[],amount:0}:this._fromOutputData(e)}async getArray(t){return(await this.db.get(t)).map(t=>"no_data"===t?{data:{},owners:[],amount:0}:this._fromOutputData(t))}async get(t){return Array.isArray(t)?this.getArray(t):this.getObject(t)}async updateArray(t,e){return this.db.update(t,e.map(this._toOutputData.bind(this)))}async updateObject(t,e,a,r=s.DEFAULT_FEE){const n={data:e,owners:a,amount:r};return(await this.db.update([t],[this._toOutputData(n)]))[0]}async update(t,e,a,s){if(Array.isArray(t)&&Array.isArray(e))return this.updateArray(t,e);if(!Array.isArray(t)&&!Array.isArray(e))return this.updateObject(t,e,a||[this.getPublicKey()],s);throw new Error("Parameters to db.update must either all be objects or both be strings.")}static getHdPrivateKey(){return X.getHdPrivateKey()}getPublicKey(){return this.db.wallet.getPublicKey().toString()}}const{PublicKey:Y,HDPrivateKey:Z}=e;class tt{constructor(t){this.token=new z(t?t.db:null)}static fromHdPrivateKey(t){const e=Z.fromString(t),a=new tt;return a.token=z.fromHdPrivateKey(e),a}async create(t){return this.token.create(t)}async send(t,e){const a=Y.fromString(e);return this.token.send(t,a)}async getBalance(){return this.token.getBalance()}getPublicKey(){return this.token.db.wallet.getPublicKey().toString()}}t.Token=tt,t.Db=Q,t.Wallet=X,Object.defineProperty(t,"__esModule",{value:!0})});
