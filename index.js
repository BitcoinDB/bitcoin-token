!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("bitcoincashflow"),require("axios"),require("conditional")):"function"==typeof define&&define.amd?define(["exports","bitcoincashflow","axios","conditional"],e):e((t["bitcoin-token-umd"]=t["bitcoin-token-umd"]||{},t["bitcoin-token-umd"].js={}),t.BitcoreLib,t.axios,t.conditional)}(this,function(t,e,a,s){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,a=a&&a.hasOwnProperty("default")?a.default:a;var n={BITCOIN_NETWORK:"testnet",BLOCK_EXPLORER_URL:"http://test-insight-4.yours.org/insight-api",CHAIN:"bitcoin-cash",MIN_SATOSHI_AMOUNT:5e3,UN_P2SH_URL:"http://localhost:3000",DEFAULT_FEE:1e4};e.versionGuard=(()=>!0),e.Networks.defaultNetwork=e.Networks[n.BITCOIN_NETWORK];class r extends Error{constructor(t,e,...a){super(...a),this.name="TokenError",this.message=t+(e?`: ${e}`:""),Error.captureStackTrace&&Error.captureStackTrace(this,r)}}function i(t){return Buffer.from(t)}function u(t){return t.toString()}class o{constructor(t,e,a){this.publicKeys=e||[],this.data=t||[],this.amount=a||n.MIN_SATOSHI_AMOUNT}getData(t){return this.data[t]}getSerializeData(){return Object.entries(this.data).reduce((t,e)=>t.concat(e),[]).map(i)}setSerializedData(t){const e=t.map(u),a={};for(let t=0;t<e.length;t+=2)a[e[t]]=e[t+1];this.data=a}toJSON(){return{data:this.data,publicKeys:this.publicKeys.map(t=>t.toString()),amount:this.amount}}}const{Address:c,PublicKey:d,Signature:h,Script:l,Opcode:p}=e;class w extends l{static buildDataOut(t){const{publicKeys:e}=t,a=t.getSerializeData(),s=new w;return s.add("OP_1"),e.forEach(t=>s.add(t.toBuffer())),s.add(`OP_${e.length}`),s.add("OP_CHECKMULTISIG"),a.forEach(t=>s.add(t).add("OP_DROP")),s}static buildDataIn(t,e,a,s){const n=new w;return a.forEach(t=>{n.add(t)}),n.add(s),n}isData(){return!(!(this.chunks.length>=5&&this.chunks[0].opcodenum===p.OP_1&&this.chunks[1].buf)||20!==this.chunks[1].buf.length&&33!==this.chunks[1].buf.length||this.chunks[2].opcodenum!==p.OP_1||this.chunks[3].opcodenum!==p.OP_CHECKMULTISIG||!this.chunks[4].buf||this.chunks[5].opcodenum!==p.OP_DROP)}toData(){if(!this.isData())return"no_data";const t=new o({},[new d(this.chunks[1].buf)],n.MIN_SATOSHI_AMOUNT),e=this.chunks.slice(4,this.chunks.length).filter((t,e)=>e%2==0).map(t=>t.buf);return t.setSerializedData(e),t}}const y=async t=>{try{return(await t).data}catch(t){if(t.response){const{status:e,statusText:a,data:s}=t.response,n=s.error||(-1!==s.indexOf("Code:")?s:a);throw new r("Communication error",`${a}. Failed with status ${e}. Txo: ${n}.`)}throw new r("Communication error","Service unavailable.")}},b=async(t,e=n.BLOCK_EXPLORER_URL)=>y(a.get(`${e}${t}`)),g=async(t,e,s=n.BLOCK_EXPLORER_URL)=>y(a.post(`${s}${t}`,e)),f=async t=>{const{balanceSat:e,unconfirmedBalanceSat:a}=await(async t=>b(`/addr/${t.toString()}`))(t);return e+a},m=async t=>{const e=t.toString();return g("/tx/send",{rawtx:e})},O=async t=>{return(await b(`/rawtx/${t}`)).rawtx},P=async t=>{const e=t.toString();return(t=>t.filter((t,e,a)=>a.findIndex(e=>e.txid===t.txid&&e.vout===t.vout)===e))(await b(`/addr/${e}/utxo`)).map(t=>(t.spent=!1,t))},K=async t=>{const e=await(async t=>b(`/tx/${t}`))(t.txId),a=e.vout[t.outputNumber],s=a.scriptPubKey.addresses[0],n=t.txId,r=t.outputNumber,i=parseFloat(a.value),u=1e8*i,o=e.blockheight,{confirmations:c}=e,d=!!a.spentTxId&&a.spentTxId;return{address:s,txid:n,vout:r,scriptPubKey:a.scriptPubKey.hex,amount:i,satoshis:u,height:o,confirmations:c,spent:d}},S=async t=>g("/",t,n.UN_P2SH_URL),D=async t=>b(`/un-p2sh/${t}`,n.UN_P2SH_URL),I=async t=>b(`/txos/${t}`,n.UN_P2SH_URL),_=async(t,e)=>g("/txos/set-spent/",{txId:t,vOut:e},n.UN_P2SH_URL),{Transaction:x,PublicKey:v,Address:T,BN:k,Script:E,encoding:H}=e,{Output:N,Input:A}=x,{MultiSigScriptHash:U}=A,{BufferReader:R}=H;class L extends x{constructor(t){super(t),this._dataOutputs=[],Object.defineProperty(this,"to",{writable:!0,value:this._to})}get dataInputs(){return this.inputs.map((t,e)=>t.redeemScript?t.redeemScript.toData(e):"no_data")}set dataInputs(t){throw Error("dataTransaction.dataInputs cannot be set directly, use dataTransaction.from or dataTransaction.fromData")}fromData(t,e){const a=w.buildDataOut(e),s=new U({output:new N({script:new w(t.scriptPubKey),satoshis:t.satoshis}),prevTxId:t.txid,outputIndex:t.vout,script:new w},e.publicKeys,1,null,a);return this.addInput(s),this}getRedeemScriptFromInput(t){if(this.inputs.length<=t)throw new Error("Input number must be smaller than number of inputs");return this.inputs[t].redeemScript||"no_data"}isInputData(t,e){if(this.inputs.length<=e)throw new Error("Input number must be smaller than number of inputs");if("no_data"===t)return!this.isDataInput(e);const a=w.buildDataOut(t),s=this.getRedeemScriptFromInput(e);return a.toString()===s.toString()}isInData(t){if(this.inputs.length!==t.length)return!1;return[...this.inputs.keys()].every(e=>this.isInputData(t[e],e))}isDataInput(t){if(this.inputs.length<=t)throw new Error("Input number must be smaller than number of inputs");return"no_data"!==this.getRedeemScriptFromInput(t)}get dataOutputs(){return this._dataOutputs.map(t=>"no_data"===t?t:new o(t.data,t.publicKeys))}set dataOutputs(t){throw Error("dataTransaction.dataInputs cannot be set directly, use dataTransaction.toData")}_to(t,e){return this._dataOutputs.push("no_data"),super.to(t,e)}toData(t){const{publicKeys:e,amount:a}=t,s=w.buildDataOut(t),n=w.buildScriptHashOut(s),r=new N({script:n,satoshis:a});return this.addOutput(r),this._dataOutputs.push(t),this}isOutputData(t,e){if(this.outputs.length<=e)throw new Error("isOutputData: Output number must be smaller than number of outputs");if("no_data"===t){const t=this.outputs[e].script.toString();return"Pay to script hash"!==w.fromString(t).classifyOutput()}const a=w.buildDataOut(t);return this.isOutputRedeemScript(a,e)}isOutData(t){if(this.outputs.length!==t.length)return!1;return[...this.outputs.keys()].every(e=>this.isOutputData(t[e],e))}isOutputRedeemScript(t,e){if(this.outputs.length<=e)throw new Error("isOutputRedeemScript: Output number must be smaller than number of outputs");const a=this.outputs[e].script;return w.buildScriptHashOut(t).toString()===a.toString()}async fetchDataOutputs(){const t=this.getId(),e=await D(t);if(!e)throw new Error(`Cannot find output string for txId ${t} in database`);return this._dataOutputs=e.map(t=>"no_data"===t?"no_data":new o(t.data,t.publicKeys.map(v.fromString))),this._dataOutputs}getOutputData(t,e){if(!this.dataOutputs)throw new Error("Need to fetch output data before retrieving it");const a=this.dataOutputs[t];if(!a||"no_data"===a)throw new Error("Not a data output");return a.data[e]}getId(){return new R(this._getHash()).readReverse().toString("hex")}async fromTxId(t){const e=await O(t);return await this.fromString(e),this}isIssuance(t){const e=[...this.inputs.keys()].every(t=>!this.isDataInput(t)),a=this.isOutData(t)||this.isOutData(t.concat(["no_data"]));return e&&a}isTransfer(t,e){const a=this.isInData(t)||this.isInData(t.concat(["no_data"])),s=this.isOutData(e)||this.isOutData(e.concat(["no_data"]));return a&&s}async getAncestors(){return await this.fetchDataOutputs(),{node:this,ancestors:await Promise.all(this.inputs.map(async(t,e)=>{if(!this.isDataInput(e))return"no_data";const a=t.prevTxId.toString("hex");return(await(new L).fromTxId(a)).getAncestors()}))}}static getGodFather(t){const{node:e,ancestors:a}=t,s=a.filter(t=>"no_data"!==t);return e.isIssuance(e.dataOutputs)?e:!!s.length&&L.getGodFather(s[0])}static isValid(t){const{node:e,ancestors:a}=t;return e.isIssuance(e.dataOutputs)?a.every(t=>"no_data"===t):!!e.isTransfer(e.dataInputs,e.dataOutputs)&&a.every(t=>L.isValid(t))}}const{HDPrivateKey:B,HDPublicKey:$,PrivateKey:C,PublicKey:F,Address:M}=e;class j{constructor(t){this._hdPrivateKey=t||new B}static fromHdPrivateKey(t){return new this(t)}getHdPrivateKey(){return this._hdPrivateKey}getPrivateKey(t=0){return this._hdPrivateKey.derive(t).privateKey}getPublicKey(t=0){return this._hdPrivateKey.hdPublicKey.derive(t).publicKey}getAddress(t=0){return this.getPublicKey(t).toAddress()}async getBalance(t=0){const e=this.getAddress(t);return f(e.toString())}async getUtxosFromAddress(t,e){const a=await P(t.toString());let s=0;const n=[];let r=0;for(;s<e&&r<a.length;)n.push(a[r]),s+=a[r].satoshis,r+=1;if(s<e)throw new Error(`Insufficient balance in address ${t.toString()}`);return n}async getUtxos(t=0,e){const a=this.getAddress(t);return this.getUtxosFromAddress(a,e)}async getTokenUtxos(t=0){const e=this.getPublicKey(t),a=await I(e.toString());return Promise.all(a.map(async t=>{const e=await(new L).fromTxId(t.txId),a=(await e.fetchDataOutputs())[t.vOut];if(a){const s=w.buildDataOut(a),n=w.buildScriptHashOut(s),r=e.outputs[t.vOut].satoshis;return{txid:t.txId,vout:t.vOut,scriptPubKey:n,amount:Math.round(r/1e8),satoshis:r,amountSat:r,dataOutput:a}}return null}))}async sendTransaction(t,e=!1){const a=await m(t.toString());if(e){const e={txId:a.txid,outputData:JSON.stringify(t.dataOutputs)};await S(e)}return a}async send(t,e,a=0,s){const r=a||0,i=s||this.getAddress(r),u=n.DEFAULT_FEE,o=this.getPrivateKey(r),c=await this.getUtxos(r,t+u),d=(new L).from(c).to(e,t).change(i).sign(o);return this.sendTransaction(d)}}const{HDPrivateKey:G,PublicKey:z}=e;class q{constructor(t){this.wallet=t||new j}static fromHdPrivateKey(t){return new this(new j(t))}async put(t){return this.update([],[t])}async get(t){const{txId:e,outputNumber:a}=t,s=await(new L).fromTxId(e);return await s.fetchDataOutputs(),s.dataOutputs[a]}async update(t,e){const a=new L;Promise.all(t.map(async t=>{const e=await K(t),s=(await D(e.txid))[e.vout],{publicKeys:n,data:r}=s,i=n.map(t=>new z(t));await _(e.txid,e.vout),a.fromData(e,new o(r,i))}));const s=await this.wallet.getUtxos(0,5e3);a.from(s);for(const t of e)a.toData(t);return a.change(this.wallet.getAddress(0)),a.sign(this.wallet.getPrivateKey(0)),{txId:(await this.wallet.sendTransaction(a,!0)).txid,outputNumber:0}}}class V{constructor(t){this.bitcoinDb=t||new q}static fromHdPrivateKey(t){return new this(q.fromHdPrivateKey(t))}async init(t){const e=Object.getPrototypeOf(async()=>{}).constructor;Object.entries(t).forEach(([t,a])=>{this[t]=new e(`"use strict"; return ${a}`).bind(this)()})}async create(t){return this.bitcoinDb.put(t)}async send(t,e){const a=await this.bitcoinDb.wallet.getTokenUtxos();let s=0;const n=a.filter(async e=>{const a=s<t,{txid:n,vout:r,dataOutput:i}=e,{balance:u}=i.data;return s+=u?parseInt(u,10):0,await _(n,r),a}).map(t=>({txId:t.txid,outputNumber:t.vout}));if(s<t)throw new Error("Insufficient token funds");const r=new o({balance:t.toString(10)},[e]),i=s-t,u=this.bitcoinDb.wallet.getPublicKey(0),c=new o({balance:i.toString(10)},[u]);return this.bitcoinDb.update(n,[r,c])}async getBalance(){const t=await this.bitcoinDb.wallet.getTokenUtxos();return(await Promise.all(t.map(async t=>{const e=await D(t.txid),{publicKeys:a,data:s}=e[t.vout],n=new o(s,a).getData("balance");return n?parseInt(n,10):0}))).reduce((t,e)=>t+e,0)}async verify(t){const e=await(new L).fromTxId(t),a=await e.getAncestors();return L.isValid(a)}}const{Address:W,HDPrivateKey:X}=e;class J{constructor(){this.wallet=new j}static fromHdPrivateKey(t){const e=new J,a=X.fromString(t);return e.wallet=j.fromHdPrivateKey(a),e}getHdPrivateKey(){return this.wallet.getHdPrivateKey().toString()}getPrivateKey(t=0){return this.wallet.getPrivateKey(t).toString()}getPublicKey(t=0){return this.wallet.getPublicKey(t).toString()}getAddress(t=0,e){const a=e||"bitpay";if(!["legacy","bitpay","cashaddr"].includes(a))throw new Error("'format' parameter in wallet.getAddress must be 'legacy', 'bitpay', or 'cashaddr'");return this.wallet.getAddress(t).toString(a)}async getBalance(t=0){return this.wallet.getBalance(t)}async send(t,e,a=0,s){const n=new W(e,"testnet"),r=s?new W(s,"testnet"):this.wallet.getAddress(0);return this.wallet.send(t,n,a,r)}}const{HDPrivateKey:Q,PublicKey:Y}=e;class Z{constructor(t){this.bitcoinDb=new q(t?t.wallet:null)}static fromHdPrivateKey(t){const e=new Z,a=Q.fromString(t);return e.bitcoinDb=q.fromHdPrivateKey(a),e}async put(t){const e=t.owners?t.owners.map(t=>new Y(t)):[this.bitcoinDb.wallet.getPublicKey(0)],a=new o(t.data,e);return this.bitcoinDb.put(a)}async get(t){const e=await this.bitcoinDb.get(t);return"no_data"===e?{data:null,owners:null,amount:null}:{data:e.data,owners:e.publicKeys,amount:e.amount}}async update(t,e){const a=e.map(t=>{const{data:e,owners:a}=t,s=a.map(t=>new Y(t));return new o(e,s)});return this.bitcoinDb.update(t,a)}getPublicKey(){return this.bitcoinDb.wallet.getPublicKey().toString()}}const{PublicKey:tt,HDPrivateKey:et}=e;class at{constructor(t){this.token=new V(t?t.bitcoinDb:null)}static fromHdPrivateKey(t){const e=et.fromString(t),a=new at;return a.token=V.fromHdPrivateKey(e),a}async create(t){const e=t.publicKeys||[this.token.bitcoinDb.wallet.getPublicKey(0)],a=new o(t.data,e);return this.token.create(a)}async send(t,e){const a=tt.fromString(e);return this.token.send(t,a)}async getBalance(){return this.token.getBalance()}getPublicKey(){return this.token.bitcoinDb.wallet.getPublicKey().toString()}}t.Token=at,t.BitcoinDb=Z,t.Wallet=J,Object.defineProperty(t,"__esModule",{value:!0})});
